<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>树莓派的奇幻漂流</title>
    <link>http://sample.com</link>
    <pubDate>2013-11-09 11:03:00 +0800</pubDate>
    <item>
      <title>记openJDK里踩过的一坑</title>
      <link>http://sample.com/坑/%E8%AE%B0openJDK%E9%87%8C%E8%B8%A9%E8%BF%87%E7%9A%84%E4%B8%80%E5%9D%91/</link>
      <pubDate>2013-10-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;自己开发机器使用的是orcale官方jdk，在本地调试ok的代码，发到厂里线上的机器，采用的openjdk的版本，发现如何调试都不通。不同jdk对同样代码采用不同的处理方式，踩进这样的坑里，着实蛋疼，排查也很难想到在这里会出问题。最后发现有问题的是以下代码，因为jdk版本的不同，导致表现的结果不一样。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public static void main(String [] args) {&#xA;    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();&#xA;    list.add(5);&#xA;    list.add(7);&#xA;    list.add(3);&#xA;    Collections.sort(list , new Comparator&amp;lt;Integer&amp;gt;() {&#xA;        @Override&#xA;        public int compare(Integer o1, Integer o2) {&#xA;            return o1 - o2 &amp;gt; 0 ? -1 : 0;&#xA;        }&#xA;    });&#xA;    System.out.println(list);&#xA;    &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在orcale jdk里，上面代面是能够按照预期正确排序的，输出结果：&lt;code&gt;[7, 5, 3]&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;open jdk里，输出结果： &lt;code&gt;[5, 7, 3]&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;原因在于&lt;code&gt;Comparator&lt;/code&gt;对&lt;code&gt;compare&lt;/code&gt;方法返回值的处理上。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;躲坑的方法把&lt;code&gt;o1 - o2 &amp;gt; 0 ? -1 : 0&lt;/code&gt;改为&lt;code&gt;o1 - o2 &amp;gt; 0 ? -1 : 1&lt;/code&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>os x10.9源码编译升级svn1.8</title>
      <link>http://sample.com/mac/os-x10.9%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%8D%87%E7%BA%A7svn1.8/</link>
      <pubDate>2013-10-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;之前升级了开发者预览版的冲浪胜地os x 10.9，发现xcode里command line tools附带的svn版本是1.7，自己很多的代码工程都是svn1.8的版本，所以需要升级svn版本到1.8。但是尝试了几种方法，发现并不是很容易，折腾了几个小时的时间，下面把过程记录如下，方便后来者。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先想到的是，升级最新的xcode5.0，这样就可以使用最新的command line tools，开始时，这种方法是凑效的，升级xcode5.0后， svn确实是1.8了。但是过了没多久，系统提示升级xcode，升级之后发现，svn版本又退回到1.7。在尝试升级command line tools无果，所以尝试别的办法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从subversion官网下载二进制的安装包，但是只有os x 10.8的，安装到一半继续不下去，此路也不通。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最后尝试svn源码编译，步骤如下：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从&lt;a href=&#34;http://subversion.apache.org/download/&#34;&gt;官网&lt;/a&gt;下载subversion-1.8.3.tar.gz（zip的试过不行），然后&lt;code&gt;tar -xvf subversion-1.8.3&lt;/code&gt;解压缩。&lt;/li&gt;&#xA;&lt;li&gt;编译源码&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd subversion-1.8.3&#xA;./configure --with-ssl&#xA;make&#xA;sudo make install&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;建立软链接&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /usr/bin&#xA;sudo ln -s ~/subversion-1.8.3/subversion/svn svn&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>coding4fun代码比赛小结</title>
      <link>http://sample.com/go/coding4fun%E4%BB%A3%E7%A0%81%E6%AF%94%E8%B5%9B%E5%B0%8F%E7%BB%93/</link>
      <pubDate>2013-08-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上周参加coding4fun的小比赛，赛题的大致意思就是充分利用多核CPU，看谁开发的程序最快。对于这类题目，语言的选择上就显得很重要，因为对于同样的算法，在都做了充分的优化的情况下，就剩下纯粹的比拼语言的执行效率了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以我选择了用go，可能有些同学还不太了解，首先看一下go语言的显著的几个特点：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.和c\c++一样都是编译型语言，直接编译成本地机器码执行，官方所说执行效率逼近c&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.语言自带垃圾回收，编译时编译进运行时&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.语言内建协程，以非常廉价的方式实现并行&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4.编程多范式支持，可以既面向过程又面向对象，还可以函数式编程&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下面简单说一下我的思路:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;1.我使用的字典树的数据结构，这种数据结构对于小文本的来说是比较有利的，后面换成大文本，字典树就有些力不从心了。基本结构就是一个节点代表一个字符，里面包含从这个节点向上遍历形成的单词的count。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;type CharTreeNode struct {&#xA;    Count    int&#xA;    Children [26]*CharTreeNode&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.总体的流程图是：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/coding4fun.png&#34; style=&#34;max-width:800px&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.申请一个很大的byte数组，一次性把文本读入内存。这个时间没什么好优化的了，因为即使是1.1G的文件，这个时间大约是600多ms。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4.多协程构建字典树。引入生产者消费者模型，有生产线程不断从byte数组中拆分byte片段，这里的拆分需要注意的是不能把一个单词拆分成两半。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后把拆分出来的byte片段的指针不断放到缓冲通道里去，同时会启动和cpu核数相当的消费者协程不断从缓冲通道里消费byte片段。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;消费者协程共享同一棵字典树，一旦拿到byte片段，就调用构建字典树的方法。这里为什么采用这样的方案是因为，最初可以分为cpu核数 大的byte片段，然后每个线程分别去构建这几个大的片段，这时会发现，分割的粒度太粗，每个协程构建字典树的时间差异很大，有的很快完成，有的会慢一些。那么最终的总耗时时间会由最慢的协程决定。所以引入生产者消费者来达到使分割的粒度足够小，每个协程的构建时间能比较平均，最后总的耗时会整体变小。这里也是利用了go语言的高效并发通信的优势，go内建了协程间的通信通道，不同执行体之间的通信不像java一样采用共享内存的方式，而是采用erlang的方案，通过语言提供的高效通信通道来通信，换用go的话说就是Do not communicate by sharing memory; instead, share memory by communicating。通过这样的优化确实能达到各个执行体的耗时比较平均，总体的提升有1秒多的样子，但是依然是主要耗时任务，这个过程差不多就要3s了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;5.等待所有协程构建字典树完成，然后遍历字典树，count的值大于1的节点向上遍历就可以形成一个单词，然后把单词和他的count插入到一个长度固定的排序的链表，就可以拿到最后的结果。这个遍历字典树和排序的过程会总共耗时30~40ms。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;6.所有消费者线程共享构建同一棵字典树，其中CharTreeNode中的count会更新非常频繁，为保证线程安全使用了和java中的AtomInteger同样的方式：&lt;code&gt;atomic.AddInt32(&amp;amp;current.Count, 1)&lt;/code&gt;。CharTreeNode另外的成员变量Children，在对某一个child赋值的时候同样存在线程安全问题，不过在所有的构建字典树协程同时对同一个节点的同一个child赋值的情况并不多，这里采用了加锁的方式保证线程安全：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;lock := &amp;amp;sync.Mutex{}&#xA;lock.Lock()&#xA;current.Children[offset] = new(CharTreeNode)&#xA;lock.Unlock()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;因为执行到这里代码块的概率非常小，我做过实验，去掉加锁，对结果的准确性和耗时的影响都微乎其微。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;比赛总结：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;所以上面的主要四个过程，可以说构建字典树占用了绝大多数的时间。这也就是文本开始是20m大小时，比较快的几个中有好多字典树的方案，到后面使用1G的文本时，他们多消失不见了。字典树这种结构个人感觉比较适合于小文本的情况，文本越大，它的劣势也就越明显。粗略估计，问题在于，字典树以字符为维度统计，而map以单词为维度统计。例如，一个小文本，可以共有100w个字符、2w种单词，比例为50；一个大文本，字符共有10000w个，单词可能是4w种，比例为2500。所以文本越大map就会相对越节省时间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;语言的选择固然重要，所以看到前五名都是c++。但是现代语言都已经很成熟，运行效率相差不大的情况下，采用的数据结构和算法才是决定因素。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派开机启动程序及启动脚本的制作</title>
      <link>http://sample.com/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E7%9A%84%E5%88%B6%E4%BD%9C/</link>
      <pubDate>2013-08-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;网上有不少关于如何让Linux自动运行自己编写的脚本或者程序的方法，但是大多数都是把命令写到/etc/rc.local里，这样虽然能够实现随机运行，但是并不够灵活。不能像mysql，apache等服务一样能够使用service命令或者调用init.d下的脚本启动、关闭或者重启进程。例如，&lt;/p&gt;&#xA;&#xA;&lt;p&gt;service mysql restart&#xA;service apache2 stop&lt;/p&gt;&#xA;&#xA;&lt;p&gt;或者&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/etc/init.d/mysql restart&#xA;/etc/init.d/apache2 stop&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为不同的Linux发行版本，对后台服务的处理方式不大一样，如redhat使用chkconfig来管理开机程序。所以下面的方法以debian类系统为例，如何写一个简单的开机启动脚本。所以，此方法适用于raspbian pi的系统。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以svn为例：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.制作开机启动脚本svn_serve&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;### BEGIN INIT INFO&#xA;# Provides:          svn_serve&#xA;# Required-Start:    $remote_fs&#xA;# Required-Stop:     $remote_fs&#xA;# Default-Start:     2 3 4 5&#xA;# Default-Stop:      0 1 6&#xA;# Short-Description: Start or stop the HTTP Proxy.&#xA;### END INIT INFO&#xA;&#xA;case $1 in&#xA;    start)&#xA;        svnserve -d -r /home/pi/svn_repository&#xA;        ;;&#xA;    stop)&#xA;        killall svnserve&#xA;        ;;&#xA;*)&#xA;echo &amp;quot;Usage: $0 (start|stop)&amp;quot;&#xA;;;&#xA;esac&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果不加上面的注释，执行下面步骤3时，update-rc.d会报如下的警告信息&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;update-rc.d: warning: /etc/init.d/proxy missing LSB information&#xA;update-rc.d: see &amp;lt;http://wiki.debian.org/LSBInitScripts&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.启动关闭服务&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo service svn_serve start&#xA;sudo service svn_serve stop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3.让svn_serve开机启动&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo update-rc.d svn_serve defaults&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4.取消svn_serve的开机自动启动&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo update-rc.d -f svn_serve remove&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>go递归函数如何传递数组切片slice</title>
      <link>http://sample.com/go/go%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87slice/</link>
      <pubDate>2013-08-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;数组切片slice这个东西看起来很美好，真正用起来会发现有诸多的不爽。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第一，数组、数组切片混淆不清，使用方式完全一样，有时候一些特性又完全不一样，搞不清原理很容易误使用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第二，数组切片的append操作，每次对slice append操作，都返回一个新的slice的引用，对slice的引用没法保持，这样在函数传递slice的情况下append，在调用函数的上下文中看不到slice append的效果。如果想要这种方式凑效，不得不另辟蹊径。本文主要说一下如何解决这个窘境的方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;第三，暂时想不起来，待补充..&lt;/p&gt;&#xA;&#xA;&lt;p&gt;函数传递slice存在什么问题？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sliceModify(slice []int) {&#xA;    // slice[0] = 88&#xA;    slice = append(slice, 6)&#xA;}&#xA;func main() {&#xA;    slice := []int{1, 2, 3, 4, 5}&#xA;    sliceModify(slice)&#xA;    fmt.Println(slice)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[1 2 3 4 5]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;问题所在：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;虽然说数组切片在函数传递时是按照引用的语义传递的，比如说在sliceModify函数里面slice[0] = 88，在方法调用的上下文中，调用函数对slice引用的改表是看得见的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是在对slice进行append操作的时候，我们惊奇的发现，这次又不管用了。原因就是append操作会返回这个扩展了的slice的引用，必须让原引用重新赋值为新slice的引用，说白了就是，传递过来的这个指针原来指了内存中的A区域，A区域是原数组的真正所在。经过一次 append之后，要把这个指针改为指向B，B对应append后新的slice的引用。但是方法调用的上下文里的slice指针还是指向了老的A内存区域。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个逻辑实在有些奇葩，这里我不得不再次吐槽append的设计。有人说这个问题好解决啊，只需要在sliceModify函数的返回值中把append后新的slice引用返回就好了。这样做当然是可以滴，但是像递归调用的函数就不好解决了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面就说一下这个问题的解决办法，方法也很简单，就是传递指针的指针。虽然有些绕，但是总算把问题解决了。当然也有其他的办法，比如按照java等语言的方式，自己实现一个ArrayList，在对可变数组扩展的时候，千万表改变引用了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func sliceModify(slice *[]int) {&#xA;    *slice = append(*slice, 6)&#xA;}&#xA;func main() {&#xA;    slice := []int{1, 2, 3, 4, 5}&#xA;    sliceModify(&amp;amp;slice)&#xA;    fmt.Println(slice)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这次就可以输出预期的结果了：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[1 2 3 4 5 6]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;递归调用的例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func insertTo10(arr *[]int) {&#xA;    length := len(*arr)&#xA;    if length == 10 {&#xA;        return&#xA;    }&#xA;    *arr = append(*arr, length)&#xA;    insertTo10(arr)&#xA;}&#xA;func main() {&#xA;    arr10 := []int{}&#xA;    insertTo10(&amp;amp;arr10)&#xA;    fmt.Println(arr10)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>go slice和数组的区别</title>
      <link>http://sample.com/go/go-slice%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>2013-08-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.使用方式&lt;/p&gt;&#xA;&#xA;&lt;p&gt;数组和slice长的很像，操作方式也都差不多，并且slice包含了数组的基本的操作方式，如下标、range循环，还有一些如len()则是多种类型共用，所以根据操作根本搞不清数组和切片的区别，能够看出区别的地方主要看如何声明的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;数组的声明方式很单一，通常就是下面这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;array1 := [5]int{1, 2, 3, 4, 5}&#xA;array2 := [5]int{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;slice的声明方式就非常多样了，如前面介绍的几种：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var slice1 = []int{1, 2, 3, 4, 5}&#xA;var slice2 = make([]int, 0, 5)&#xA;var slice3 = make([]int, 5, 5)&#xA;var slice4 = make([]int, 5)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;加上对数组的切片和append操作都会产生数组切片(slice)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.值传递or引用传递&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func arrayModify(array [5]int) {&#xA;    newArray := array&#xA;    newArray[0] = 88&#xA;}&#xA;func sliceModify(slice []int) {&#xA;    newSlice := slice&#xA;    newSlice[0] = 88&#xA;}&#xA;func main() {&#xA;    array := [5]int{1, 2, 3, 4, 5}&#xA;    slice := []int{1, 2, 3, 4, 5}&#xA;    arrayModify(array)&#xA;    sliceModify(slice)&#xA;    fmt.Println(array)&#xA;    fmt.Println(slice)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[1 2 3 4 5]&#xA;[88 2 3 4 5]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其实不只是数组，go语言中的大多数类型在函数中当作参数传递都是值语义的。也就是任何值语义的一种类型当作参数传递到调用的函数中，都会经过一次内容的copy，从一个方法栈中copy到另一个方法栈。这对于熟练java的同学需要进行一次彻底的观念转变，在java中除了少数的值类型是按照值传递，所有的类在函数传递时都是具有引用语义的，也就是通过指针传递。所以在使用时传递对象，不需要去分别值和引用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;go说到底不是一种纯粹的面向对象的语言，更多的是一种更简单高效的C，所以在参数传递上跟C保持着基本的一致性。一些较大的数据类型，比如结构体、数组等，最好使用传递指针的方式，这样就能避免在函数传递时对数据的copy。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;虽然slice在传递时是按照引用语义传递，但是又因为append()操作的问题，导致即使是引用传递还是不能顺利解决一些问题，后面一篇文章将说明一下如何解决递归函数中传递slice的问题：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.codeforfun.info/go/go%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87slice/&#34;&gt;go递归函数如何传递数组切片slice&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>go语言中的数组切片slice</title>
      <link>http://sample.com/go/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87slice/</link>
      <pubDate>2013-08-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;初看go语言中的slice，觉得是可变数组的一种很不错的实现，直接在语言语法的层面支持，操作方面比起java中的ArrayList方便了许多。但是在使用了一段时间后，觉得这东西埋的坑不少，使用方式上和arrayList也有很大的不同，在使用时要格外注意。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;slice的数据结构&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;首先说一下slice的数据结构，源码可以在google code上找到，&lt;a href=&#34;http://code.google.com/p/go/source/browse/src/pkg/runtime/runtime.h&#34;&gt;http://code.google.com/p/go/source/browse/src/pkg/runtime/runtime.h&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;struct Slice&#xA;{                          &#xA;    byte*   array;  // actual data&#xA;    uintgo  len;    // number of elements&#xA;    uintgo  cap;    // allocated number of elements&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看出主要保存了三个信息：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一个指向原生数组的指针&lt;/li&gt;&#xA;&lt;li&gt;元素的个数&lt;/li&gt;&#xA;&lt;li&gt;数组分配的存储空间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;slice的基本操作&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;go中生成切片的方式有以下几种，这几种生成方式也对应了对slice的基本操作，每个操作后面go隐藏了很多的细节，如果没有对其足够了解，在使用时很容易被这些坑绊倒。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1.make函数生成&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这是最基本，最原始生成slice切片的方式，通过其他方式生成的切片最终也是通过这种方式来完成。因为无论如何都需要填充上面slice结构的三个最基本信息。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过查找源码，发现最终都是经过下面的c代码实现的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;static void makeslice1(SliceType *t, intgo len, intgo cap, Slice *ret)&#xA;{&#xA;    ret-&amp;gt;len = len;&#xA;    ret-&amp;gt;cap = cap;&#xA;    ret-&amp;gt;array = runtime·cnewarray(t-&amp;gt;elem, cap);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;make函数在生成slice时的写法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var slice1 = make([]int, 0, 5)&#xA;var slice2 = make([]int, 5, 5)&#xA;// 省略len的写法，len默认等于cap，相当于make([]int, 5, 5)&#xA;var slice3 = make([]int, 5)     &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这个简便的写法实在是有点坑爹，如果你写成make([]int, 5)，go会默认把数组长度len当作slice的容量，按照上面的例子，便生成了这样的结构：&lt;code&gt;[0 0 0 0 0]&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.对数组进行切片&#xA;首先来看下面的代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;arr := [5]int{1, 2, 3, 4, 5}&#xA;slice := arr[3 : 5] //  slice:[4, 5]&#xA;slice[0] = 0        // slice:[0, 5]&#xA;fmt.Println(slice)&#xA;fmt.Println(arr)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出结果：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[0 5]&#xA;[1 2 3 0 5]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从上面可以看出，对数组进行了切片操作，生成的切片里的array指针实际指向了原数组的一个位置，相当于c的代码中对原数组截取生成新的数组[2]arrNew，数组的指针指向arr[3]，所以改变切片里0下标对应元素的值，实际上也就改变了原数组相应数组位置3中元素的值。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于这个问题这篇博文说的比较详细：&lt;a href=&#34;http://sharecore.info/blog/2013/07/23/the-trap-of-go-slice-appending/&#34;&gt;对Go的Slice进行Append的一个“坑”&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.对数组或切片进行append&lt;/p&gt;&#xA;&#xA;&lt;p&gt;个人认为这个append是go语言中实现地不太优雅的一个地方，比如对一个slice进行append必须要这样写：&lt;code&gt;slice = append(slice, 1)&lt;/code&gt;。说白了就是，对一个slice进行append时，必须把新的引用重新赋值给slice。如果只是语法上怪异，那问题还好，只是代码写起来麻烦一点。但是实际情况是这个append操作导致的问题多多，不小心很容易走到append埋的坑里面去。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先来看一个比较奇怪的现象：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var sliceA = make([]int, 0, 5)&#xA;sliceB := append(sliceA, 1)&#xA;fmt.Println(sliceA)&#xA;fmt.Println(sliceB)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出结果是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[]&#xA;[1]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;刚看到这样的结果时让人很难以理解，明明声明了容量是5的切片，现在sliceA的len是0，远没有达到切片的容量。按理说对sliceA进行append操作，在没有达到切片容量的情况下根本不需要重新申请一个新的大容量的数组，只需要在原本数组内修改元素的值。而且，go函数在传输切片时是引用传递，这样的话，sliceB和sliceA应该输出一样才对。看到这样的结果，着实让人困惑了很长时间，难道每次append操作都会重新分配数组吗？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;答案肯定不是这样的，如果真是这样的话，go也就不用再混了，性能肯定会出问题。下面从go实现append的源码中去找答案，源码位置在：&lt;a href=&#34;http://code.google.com/p/go/source/browse/src/pkg/runtime/slice.c&#34;&gt;http://code.google.com/p/go/source/browse/src/pkg/runtime/slice.c&lt;/a&gt;&#xA;代码很长，这里只截取关键的片段来说明问题：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;void runtime·appendslice(SliceType *t, Slice x, Slice y, Slice ret)&#xA;{&#xA;    intgo m = x.len+y.len;&#xA;    void *pc;&#xA;    if(m &amp;gt; x.cap)&#xA;        growslice1(t, x, m, &amp;amp;ret);&#xA;    else&#xA;        ret = x;&#xA;    // read x[:len]&#xA;    if(m &amp;gt; x.cap)&#xA;        runtime·racereadrangepc(x.array, x.len*w, pc, runtime·appendslice);&#xA;    // read y&#xA;    runtime·racereadrangepc(y.array, y.len*w, pc, runtime·appendslice);&#xA;    // write x[len(x):len(x)+len(y)]&#xA;    if(m &amp;lt;= x.cap)&#xA;        runtime·racewriterangepc(ret.array+ret.len*w, y.len*w, pc, runtime·appendslice);&#xA;    ret.len += y.len;&#xA;    FLUSH(&amp;amp;ret);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数定义&lt;code&gt;appendslice(SliceType *t, Slice x, Slice y, Slice ret)&lt;/code&gt;，对应&lt;code&gt;slice3 = append(slice1, slice1...)&lt;/code&gt;操作，分别代表：数组里的元素类型、slice1, slice2, slice3。虽然append()语法中，第二个参数不能为slice，但是第二个参数其实是一个可变参数&lt;code&gt;elems ...Type&lt;/code&gt;，可以传输打散的数组，所以go在处理时同样是转换为slice来操作的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从上面的代码很清楚的看到，如果x.len + y.len 超过了x.cap，那么就会重新扩展新的切片，如果x.len + y.len还没有超过x.cap，则还是在原切片的数组中进行元素的填充。那么这样跟我们理性的认识是一致的。可以打消掉之前误解的对go append的担心。那问题出在哪呢？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;上面忽略了一点，append函数是有go的代码的，不是直接语言级c的实现，在c的实现上还加了go语言自己的处理，在/pkg/builtin/bulitin.go里有函数的定义。这里我只能假设在go的层面对scliceA做了一些隐秘的处理，go如何去调用c的底层实现，我现在还不甚了解，这里也只能分析到这里。以后了解之后再来补充这篇博客，如果有了解的朋友，也非常感激你告诉我。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4.声明无长度的数组&lt;/p&gt;&#xA;&#xA;&lt;p&gt;声明无长度的数组其实就是声明了一个可变数组，也就是slice切片。只不过这个切片的len和cap都是0。这个方法写起来非常方便，如果不了解其背后的实现，那么这样用起来是性能最差的一种。因为会导致频繁的对slice进行重新申请内容的操作，并且需要把，原数组中的元素copy到新的大容量的数组里去。每次重新分配数组容量的步长是len*2，如果进行n次append，那么需要经过log2(n)次的重新申请内存和copy的开销。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;后面的一篇文章会继续介绍切片和数组的一些区别:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.codeforfun.info/go/go-slice%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/&#34;&gt;go slice和数组的区别&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>go实现排序的链表</title>
      <link>http://sample.com/go/go%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>2013-08-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;链表的数据结构比较线性数组，优点是 可以方便的对任意的位置进行插入和删除。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这一特性使得它很适合于应用在排序等场景下，由于golang目前类库还不是很完善，在java中可以很简单的使用api提供的支持完成对list或者map的排序，在使用go时就没有那么幸运了，可能需要自己去实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的例子就是使用go package 中的LinkedList实现的排序的链表。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有几个功能特性：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;1.支持固定的长度&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2.可自定义排序的规则&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3.组合LinkedList功能&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package codeforfun&#xA;import (&#xA;    &amp;quot;container/list&amp;quot;&#xA;)&#xA;type SortedLinkedList struct {&#xA;    *list.List&#xA;    Limit int&#xA;    compareFunc func (old, new interface{}) bool&#xA;}&#xA;func NewSortedLinkedList(limit int, compare func (old, new interface{}) bool) *SortedLinkedList {&#xA;    return &amp;amp;SortedLinkedList{list.New(), limit, compare}&#xA;}&#xA;func (this SortedLinkedList) findInsertPlaceElement(value interface{}) *list.Element {&#xA;    for element := this.Front(); element != nil; element = element.Next() {&#xA;        tempValue := element.Value&#xA;        if this.compareFunc(tempValue, value) {&#xA;            return element&#xA;        }&#xA;    }&#xA;    return nil&#xA;}&#xA;func (this SortedLinkedList) PutOnTop(value interface{}) {&#xA;    if this.List.Len() == 0 {&#xA;        this.PushFront(value)&#xA;        return&#xA;    }&#xA;    if this.List.Len() &amp;lt; this.Limit &amp;amp;&amp;amp; this.compareFunc(value, this.Back().Value) {&#xA;        this.PushBack(value)&#xA;        return&#xA;    }&#xA;    if this.compareFunc(this.List.Front().Value, value) {&#xA;        this.PushFront(value)&#xA;    } else if this.compareFunc(this.List.Back().Value, value) &amp;amp;&amp;amp; this.compareFunc(value, this.Front().Value) {&#xA;        element := this.findInsertPlaceElement(value)&#xA;        if element != nil {&#xA;            this.InsertBefore(value, element)&#xA;        }&#xA;    }&#xA;    if this.Len() &amp;gt; this.Limit {&#xA;        this.Remove(this.Back())&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用方法：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;codeforfun&amp;quot;&#xA;)&#xA;type WordCount struct {&#xA;    Word  string&#xA;    Count int&#xA;}&#xA;func compareValue(old, new interface {}) bool {&#xA;    if new.(WordCount).Count &amp;gt; old.(WordCount).Count {&#xA;        return true&#xA;    }&#xA;    return false&#xA;}&#xA;func main() {&#xA;    wordCounts := []WordCount{&#xA;        WordCount{&amp;quot;kate&amp;quot;, 87},&#xA;        WordCount{&amp;quot;herry&amp;quot;, 92},&#xA;        WordCount{&amp;quot;james&amp;quot;, 81}}&#xA;    var aSortedLinkedList = codeforfun.NewSortedLinkedList(10, compareValue)&#xA;    for _, wordCount := range wordCounts {&#xA;        aSortedLinkedList.PutOnTop(wordCount)&#xA;    }&#xA;    for element := aSortedLinkedList.List.Front(); element != nil; element = element.Next() {&#xA;        fmt.Println(element.Value.(WordCount))&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>java函数式编程之lambda表达式</title>
      <link>http://sample.com/java/java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>2013-08-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;作为比较老牌的面向对象的编程语言java，在对函数式编程的支持上一直不温不火。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;认为面向对象式编程就应该纯粹的面向对象，于是经常看到这样的写法：如果你想写一个方法，那么就必须把它放到一个类里面，然后new出来对象，对象调用这个方法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这种方式在函数式编程语言看来太死板，没有必要在对待多种编程范式上采取非此即彼的做法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如今比较现代的编程语言也都是多编程范式的支持，不再去对一种编程范式固守一隅，一种语言可能会同时具有面向对象、函数式、元编程等多种特性，这方面java的后来者C#都走在她的前面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;终于在jdk8里发现了lambda表达式的影子，java也开始加入这种函数式编程特性，java码农们终于在之前老土的方法之外有了一种更为简便的选择。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首先来看，lambda之前java的做法：&#xA;使用匿名内部类：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void testAnonymousClass() {&#xA;    Integer[] nums = {2, 5, 1, 6};&#xA;    Arrays.sort(nums, new Comparator&amp;lt;Integer&amp;gt;() {&#xA;        @Override&#xA;        public int compare(Integer o1, Integer o2) {&#xA;            if(o1 &amp;lt; o2) &#xA;                return -1;&#xA;            return 0;&#xA;        }&#xA;    });&#xA;    for (Integer n : nums) {&#xA;        System.out.println(n);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;函数式编程语言的做法，这里拿go的代码为例：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;// 插入排序&#xA;func sort(nums []int, compare func (a, b int) int) {&#xA;    length := len(nums)&#xA;    for i := length - 1; i &amp;gt;= 0; i-- {&#xA;        for j := i; j + 1 &amp;lt; length; j++ {&#xA;            cur := nums[j]&#xA;            next := nums[j + 1]&#xA;            if compare(cur, next) &amp;gt; 0 {&#xA;                nums[j], nums[j + 1] = next, cur&#xA;            }&#xA;        }&#xA;    }&#xA;}&#xA;func main() {&#xA;    nums := []int{2, 5, 1, 6}&#xA;    sort(nums, func(a, b int) int {&#xA;            if a &amp;gt; b {&#xA;                return 1&#xA;            }&#xA;            return 0&#xA;        })&#xA;    fmt.Println(nums)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;go的代码看上去比较长，由于没有像java一样使用类库提供的排序算法，所以go自己实现的插入排序。&#xA;这里go语言具有函数里面传函数的能力（也叫高阶函数），所以代码看起来简洁了很多。一般这种场景，函数式编程语言使用匿名函数的方式，在java的看来就必须通过匿名内部类来实现。首先实现一个接口，接口里面定义好方法，匿名内部类实现接口，然后在传入的函数中，通过传递的对象，实现对匿名内部类里的方法的回调。这也就是lambda表达式之前的基本做法。&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;lambda表达式是对java实现函数式编程一个取巧方式的补充，下面来看lambda方式的做法：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public void testAnonymousClass() {&#xA;    Integer[] nums = {2, 5, 1, 6};&#xA;    Arrays.sort(nums, (o1, o2) -&amp;gt; {&#xA;        if(o1 &amp;lt; o2) &#xA;            return -1;&#xA;        return 0;&#xA;    });&#xA;    for (Integer n : nums) {&#xA;        System.out.println(n);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;函数式接口：这是java在解决函数式编程，引入lambda表达式的同时引入的一个概念，具体的意思就是，定义的一个接口，接口里面必须有且只有一个方法，这样的接口就成为函数式接口。&#xA;在可以使用lambda表达式的地方，方法声明时必须包含一个函数式的接口。任何函数式接口都可以使用lambda表达式替换。&#xA;下面来看lambda的基本逻辑：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;button.onAction(new EventHandler&amp;lt;ActionEvent&amp;gt;() {&#xA;    @Override&#xA;    public void handle(ActionEvent e) {&#xA;        doSomethingWith(e);&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用lambda表达式替换：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;button.onAction((ActionEvent e) -&amp;gt; {&#xA;    doSomethingWith(e);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;此lambda表达式的类型可由编译器推断为EventHandler&lt;ActionEvent&gt;，因为onAction()方法采用的对象类型为 EventHandler&lt;ActionEvent&gt;。&#xA;由于EventHandler只有一个方法即handle()，此lambda表达式必然是handle()方法的实现。&#xA;可以继续简化lambda表达式：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;button.onAction((e) -&amp;gt; {&#xA;    doSomethingWith(e);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;此lambda表达式的参数必须是ActionEvent，因为其类型是由EventHandler接口的 handle()方法指定的。&#xA;因此，我们可以简化此lambda表达式，因为其参数类型可以推断。&#xA;还可以继续简化：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;button.onAction(e -&amp;gt; doSomethingWith(e));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当lambda表达式只有一个参数且参数类型可以推断时，则不需要括号。&#xA;lambda表达式中的代码块只包含一个语句，因此可以去掉大括号和分号。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可以猜测lambda表达式的实现可能是由java编译器在编译java字节码时，会翻译这样的语法糖，最终还是转化为匿名内部类来实现，至少从语义上看来是这样的。那么它究竟怎样做到的，这里的文章可以给出答案：&#xA;&lt;a href=&#34;http://developer.51cto.com/art/201302/380803.htm&#34;&gt;和Lambdas的第一次亲密接触&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;采用的办法是在使用lambda表达式的类中生成一个实例方法，那么当然能够访问到这个类中定义的实例变量、静态变量和公开、私有方法。&#xA;那和函数式编程相随相生的闭包问题是否支持了呢？&#xA;通过上面的介绍可以看出java对函数式编程的实现，主要还是在编译时对lambda表达式的一些转化。&#xA;让人看起来像是支持了匿名函数等函数式编程的特性，其实还是使用java自己的一套实现。所以在使用lambda表达式的时候最好头脑清醒，不要纠结是否闭包了。&#xA;以上谈的是jdk8的预览版本，也可能正式版会做很多的改进，那就不得而知了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相关文章：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://developer.51cto.com/art/201304/387681.htm&#34;&gt;Java 8为什么需要Lambda表达式&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://developer.51cto.com/art/201206/344308.htm&#34;&gt;Java 8的Lambda表达式&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/xuqingfeng/archive/2013/04/26/about-Java8-lambda-expression.html&#34;&gt;说说Java 8中的Lambda表达式&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>go语言channel的别样用法</title>
      <link>http://sample.com/go/go%E8%AF%AD%E8%A8%80channel%E7%9A%84%E5%88%AB%E6%A0%B7%E7%94%A8%E6%B3%95/</link>
      <pubDate>2013-07-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.返回值使用通道&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    // 生成随机数作为一个服务&#xA;    randService := randGenerator()&#xA;    // 从服务中读取随机数并打印&#xA;    fmt.Printf(&amp;quot;%d\n&amp;quot;,&amp;lt;-randService)&#xA;}&#xA;func randGenerator() chan int {&#xA;    // 创建通道&#xA;    out := make(chan int)&#xA;    // 创建协程&#xA;    go func() {&#xA;        for {&#xA;            //向通道内写入数据，如果无人读取会等待&#xA;            out &amp;lt;- rand.Int()&#xA;        }&#xA;    }()&#xA;    return out&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2.参数使用通道&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//一个查询结构体&#xA;type query struct {&#xA;    //参数Channel&#xA;    sql chan string&#xA;    //结果Channel&#xA;    result chan string&#xA;}&#xA;//执行Query&#xA;func execQuery(q query) {&#xA;    //启动协程&#xA;    go func() {&#xA;        //获取输入&#xA;        sql := &amp;lt;-q.sql&#xA;        //访问数据库，输出结果通道&#xA;        q.result &amp;lt;- &amp;quot;get&amp;quot; + sql&#xA;    }()&#xA;}&#xA;func main() {&#xA;    //初始化Query&#xA;    q := query{make(chan string, 1),make(chan string, 1)}&#xA;    //执行Query，注意执行的时候无需准备参数&#xA;    execQuery(q)&#xA;    //准备参数&#xA;    q.sql &amp;lt;- &amp;quot;select * from table&amp;quot;&#xA;    //获取结果&#xA;    fmt.Println(&amp;lt;-q.result)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;3.并发循环&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func doSomething(num int) (sum int) {&#xA;    for i := 1; i &amp;lt;= 10; i++ {&#xA;        fmt.Printf(&amp;quot;%d + %d = %d\n&amp;quot;, num, num + i, num + num + i)&#xA;        sum = sum + num + i&#xA;    }&#xA;    return sum&#xA;}&#xA;func testLoop() {&#xA;    // 建立计数器，通道大小为cpu核数&#xA;    var NumCPU = runtime.NumCPU()&#xA;    fmt.Printf(&amp;quot;NumCPU = %d\n&amp;quot;, NumCPU)&#xA;    sem :=make(chan int, NumCPU);&#xA;    //FOR循环体&#xA;    data := []int{1, 11, 21, 31, 41, 51, 61, 71, 81, 91}&#xA;    for _,v:= range data {&#xA;        //建立协程&#xA;        go func (v int) {&#xA;            fmt.Printf(&amp;quot;doSomething(%d)...\n&amp;quot;, v)&#xA;            sum := doSomething(v);&#xA;            //计数&#xA;            sem &amp;lt;- sum;&#xA;        } (v);&#xA;    }&#xA;    // 等待循环结束&#xA;    var total int = 0&#xA;    for i := 0; i &amp;lt; len(data); i++ {&#xA;        temp := &amp;lt;- sem&#xA;        fmt.Printf(&amp;quot;%d &amp;lt;- sem\n&amp;quot;, temp)&#xA;        total = total + temp&#xA;    }&#xA;    fmt.Printf(&amp;quot;total = %d\n&amp;quot;, total)&#xA;}&#xA;func main() {&#xA;    testLoop()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;4.利用channel计算素数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Send the sequence 2, 3, 4, ... to channel &#39;in&#39;.&#xA;func Generate(ch chan int) {&#xA;    for i := 2; ; i++ {&#xA;        ch&amp;lt;- i // Send &#39;i&#39; to channel &#39;in&#39;.&#xA;    }&#xA;}&#xA;// Copy the values from channel &#39;in&#39; to channel &#39;out&#39;,&#xA;// removing those divisible by &#39;prime&#39;.&#xA;func Filter(in chan int, out chan int, prime int) {&#xA;    for {&#xA;        i := &amp;lt;-in // Receive valuefrom &#39;in&#39;.&#xA;        if i%prime != 0 {&#xA;            out &amp;lt;- i // Send&#39;i&#39; to &#39;out&#39;.&#xA;        }&#xA;    }&#xA;}&#xA;func main() {&#xA;    in := make(chan int)&#xA;    go Generate(in)      // Launch Generate goroutine.&#xA;    for i := 0; i &amp;lt; 100; i++ {&#xA;        prime := &amp;lt;-in&#xA;        print(prime, &amp;quot;\n&amp;quot;)&#xA;        out := make(chan int)&#xA;        go Filter(in, out, prime)&#xA;        in = out&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;5.共享变量的读写&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//共享变量有一个读通道和一个写通道组成&#xA;type shardedVar struct {&#xA;    reader chan int&#xA;    writer chan int&#xA;}&#xA;//共享变量维护协程&#xA;func whachdog(v shardedVar) {&#xA;    go func() {&#xA;        //初始值&#xA;        var value int = 0&#xA;        for {&#xA;            //监听读写通道，完成服务&#xA;            select {&#xA;            case value = &amp;lt;-v.writer:&#xA;            case v.reader &amp;lt;-value:&#xA;            }&#xA;        }&#xA;    }()&#xA;}&#xA;func main() {&#xA;    //初始化，并开始维护协程&#xA;    v := shardedVar{make(chan int), make(chan int)}&#xA;    whachdog(v)&#xA;    //读取初始值&#xA;    fmt.Println(&amp;lt;-v.reader)&#xA;    //写入一个值&#xA;    v.writer &amp;lt;- 1&#xA;    //读取新写入的值&#xA;    fmt.Println(&amp;lt;-v.reader)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>idea intellij go &#34;can’t find import&#34; 解决方法</title>
      <link>http://sample.com/go/idea-intellij-go-%22can%E2%80%99t-find-import%22-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>2013-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;尝试重多golang的ide，最后发现intellij目前做的完成度最高&lt;/p&gt;&#xA;&#xA;&lt;p&gt;eclipse go 不能进行包、类、方法等的跳转，这点是无法忍受的，所以果断换成intellij&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是发现在intellij里面不能import &lt;code&gt;$GOPATH&lt;/code&gt;里src下的包，网上搜索了很长时间，&#xA;在这里找到解决方法：&lt;a href=&#34;https://github.com/mtoader/google-go-lang-idea-plugin/issues/224&#34;&gt;https://github.com/mtoader/google-go-lang-idea-plugin/issues/224&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;Looking through the source, it seems that the plugin doesn&#39;t use the $GOPATH (to be fair, I think earlier Go docs didn&#39;t make the distinction between using $GOPATH and $GOROOT quite as clear as they do now).&#xA;In setting up the plugin you have to &#xA;1.) create symlinks for all of the imported package directories in your $GOPATH:&#xA;    a. $GOROOT/src/pkg/ -&amp;gt; $GOPATH/src&#xA;    ex. from within $GOROOT/src/pkg, ln -s $GOPATH/src/github.com&#xA;    b. $GOROOT/pkg/target/ -&amp;gt; $GOPATH/pkg/target/&#xA;    ex. from within $GOROOT/pkg/darwin_amd64, ln -s $GOPATH/pkg/darwin_amd64/code.google.com&#xA;2.) you MUST set up a source directory when creating the project (however, it can be an empty string, which will then cause the wizard to prompt you that it will set the project root as the source directory)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;附上一片比较完整搭建go环境的博文：&#xA;&lt;a href=&#34;http://icfly.cn/archives/2013/05/golang-ide.html&#34;&gt;http://icfly.cn/archives/2013/05/golang-ide.html&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派折腾手记</title>
      <link>http://sample.com/raspberry/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8A%98%E8%85%BE%E6%89%8B%E8%AE%B0/</link>
      <pubDate>2013-05-22 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;OS X下通过下面的命令能够把镜像写入SD&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;unzip 2013-02-09-wheezy-raspbian.zip&#xA;df -h&#xA;sudo diskutil unmount /dev/rdisk1s1&#xA;sudo dd bs=1m if=2013-02-09-wheezy-raspbian.img of=/dev/rdisk1&#xA;sudo diskutil eject /dev/rdisk1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更换了一个更加快速的源&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;pi的源列表: &lt;a href=&#34;http://www.raspbian.org/RaspbianMirrors&#34;&gt;http://www.raspbian.org/RaspbianMirrors&lt;/a&gt; 测试了之后发现这个源在国内更新最快 &lt;a href=&#34;http://mirror.devunt.kr/raspbian/raspbian/&#34;&gt;http://mirror.devunt.kr/raspbian/raspbian/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更换源：&#xA;&lt;code&gt;sudo vi /etc/apt/sources.list&lt;/code&gt;&#xA;更改为：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;deb http://mirror.devunt.kr/raspbian/raspbian/ wheezy main contrib non-free rpi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更新系统:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更新固件：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo apt-get install git-core&#xA;$ sudo wget http://goo.gl/1BOfJ -O /usr/bin/rpi-update &amp;amp;&amp;amp; sudo chmod +x /usr/bin/rpi-update&#xA;$ sudo rpi-update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;命令行下显示中文&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sudo apt-get install ttf-wqy-zenhei&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;中文安装完成之后还需要一个输入法：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sudo apt-get install scim-pinyin&lt;/code&gt;&#xA;然后&lt;code&gt;sudo raspi-config&lt;/code&gt;选择change_locale，&#xA;用空格键选择四个中文字体zh_CN.GB2312, zh_CN.GB18030, zh_CN GBK, zh_CN.UTF-8，&#xA;选择zh_CN.UTF-8作为系统环境默认区域设置，然后重启&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;安装需要的软件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;vim&#xA;&lt;code&gt;sudo apt-get install vim&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;chrome&#xA;&lt;code&gt;sudo apt-get install chromium-browser chromium-l10n&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;远程桌面&#xA;&lt;code&gt;sudo apt-get install xrdp&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;通过x2x和Raspberry Pi共享鼠标键盘&#xA;&lt;a href=&#34;http://blog.xming.me/?p=72&#34;&gt;http://blog.xming.me/?p=72&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装node.js&#xA;&lt;a href=&#34;http://www.jeremymorgan.com/tutorials/raspberry-pi/how-to-install-node-js-raspberry-pi/&#34;&gt;http://www.jeremymorgan.com/tutorials/raspberry-pi/how-to-install-node-js-raspberry-pi/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;编译Go语言&#xA;&lt;a href=&#34;http://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi&#34;&gt;http://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;树莓派shell命令&#xA;重新配置树莓派：&lt;code&gt;sudo raspi-config&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;查看cpu温度：&lt;code&gt;cat /sys/class/thermal/thermal_zone0/temp&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;配置无线网络和固定ip&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;命令查看USB设备列表&lt;code&gt;lsusb&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;扫描无线网络&lt;code&gt;sudo iwlist wlan0 scan&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/wpa_supplicant/wpa_supplicant.conf&#xA;    network={&#xA;    ssid=&amp;quot;TP-LINK_B3A8BC&amp;quot;&#xA;    proto=RSN&#xA;    key_mgmt=WPA-PSK&#xA;    pairwise=CCMP TKIP&#xA;    group=CCMP TKIP&#xA;    psk=&amp;quot;password&amp;quot;&#xA;    }&#xA;$ sudo vim /etc/network/interfaces&#xA;    auto lo&#xA;    iface lo inet loopback&#xA;    iface eth0 inet dhcp&#xA;    allow-hotplug wlan0&#xA;    iface wlan0 inet manual&#xA;    wpa-roam /etc/wpa.conf&#xA;    address 192.168.1.109&#xA;    netmask 255.255.255.0&#xA;    network 192.168.1.0&#xA;    broastcast 192.168.1.255&#xA;    gateway 192.168.1.1&#xA;    iface default inet dhcp&#xA;$ sudo ifdown wlan0&#xA;$ sudo ifup wlan0&#xA;$ iwconfig&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;安装samba&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install samba&#xA;sudo cp /etc/samba/smb.conf  /etc/samba/smb.conf.bak&#xA;sudo vim /etc/samba/smb.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置security = user&lt;/p&gt;&#xA;&#xA;&lt;p&gt;配置共享位置，在文件末添加：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[media]&#xA;comment = pi sd card&#xA;path = /home/pi/samba&#xA;valid users = @users&#xA;force group = users&#xA;create mask = 0660&#xA;directory mask = 0771&#xA;read only = no&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;重启samba&#xA;sudo service samba restart&#xA;windows下，在运行里面:\:[树莓派ip]访问，&#xA;macox在safari里访问 smb://[树莓派ip]&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;媒体播放&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用方法：在终端用命令打开：omxplayer + 文件名，如果用HDMI接口的音频输出的话要加上-o hdmi参数&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Key    Action&#xA;1    　　加速&#xA;2    　　减速&#xA;j    　　上一条音轨&#xA;k    　　下一条音轨&#xA;i    　　上一节&#xA;o    　　下一节&#xA;n    　　上一条字幕轨&#xA;m    　　下一条字幕轨&#xA;s    　　显示/不显示字幕&#xA;q    　　退出&#xA;空格或p　　暂停/继续&#xA;-    　　减小音量&#xA;+    　　增加音量&#xA;左    　　后退30&#xA;右    　　前进30&#xA;上    　　后退600&#xA;下    　　前进600&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;树莓派的应用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Hacking a Raspberry Pi into a wireless airplay speaker&#xA;&lt;a href=&#34;http://jordanburgess.com/post/38986434391/raspberry-pi-airplay&#34;&gt;http://jordanburgess.com/post/38986434391/raspberry-pi-airplay&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;超频的玩法&#xA;&lt;a href=&#34;http://www.oschina.net/translate/how-to-overclock-raspberry-pi&#34;&gt;http://www.oschina.net/translate/how-to-overclock-raspberry-pi&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://jade.is-programmer.com/posts/36984.html&#34;&gt;http://jade.is-programmer.com/posts/36984.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.memetic.org/raspberry-pi-overclocking/&#34;&gt;http://www.memetic.org/raspberry-pi-overclocking/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;启动配置项说明&#xA;&lt;a href=&#34;http://elinux.org/RPiconfig&#34;&gt;http://elinux.org/RPiconfig&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;很强大的玩法，树莓派集群&#xA;&lt;a href=&#34;http://www.southampton.ac.uk/~sjc/raspberrypi/pi_supercomputer_southampton.htm&#34;&gt;http://www.southampton.ac.uk/~sjc/raspberrypi/pi_supercomputer_southampton.htm&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;rpi-update更新firmware&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo wget http://goo.gl/1BOfJ -O /usr/bin/rpi-update &amp;amp;&amp;amp; sudo chmod +x /usr/bin/rpi-update&#xA;sudo apt-get install ca-certificates&#xA;sudo apt-get install git-core&#xA;sudo rpi-update&#xA;sudo reboot&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更多参考：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;http://blog.sina.com.cn/s/blog_3cb6a78c0101a0fe.html&amp;gt;&#xA;&amp;lt;http://hi.baidu.com/nonezk/item/e2c82a03683e2c95a3df4344&amp;gt;&#xA;&amp;lt;http://blog.linguofeng.com/archive/2013/04/04/raspberry-pi.html&amp;gt;&#xA;&amp;lt;http://www.leiphone.com/raspberry-pi-hands-on.html&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;在一张SD卡上安装多个系统&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.berryterminal.com/doku.php/berryboot#adding_your_own_custom_operating_systems_to_the_menu&#34;&gt;http://www.berryterminal.com/doku.php/berryboot#adding_your_own_custom_operating_systems_to_the_menu&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用ssh远程切换berryboot默认系统&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://rvalbuena.blogspot.com/2013/02/changing-berryboot-selected-os-on.html&#34;&gt;http://rvalbuena.blogspot.com/2013/02/changing-berryboot-selected-os-on.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;用树莓派搭建独立博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用disqus，增加评论功能&#xA;&lt;a href=&#34;http://disqus.com&#34;&gt;http://disqus.com&lt;/a&gt;&#xA;可以参考的静态博客网站&#xA;在Pi和Github上搭建自己的个人博客&lt;/p&gt;&#xA;&#xA;&lt;p&gt;gor:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://defworld.com/2013-05/build-your-blog-with-gor-and-pi.html&#34;&gt;http://defworld.com/2013-05/build-your-blog-with-gor-and-pi.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Jekyll:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://blog.huatai.me/2013/04/18/using-jekyll.html&#34;&gt;http://blog.huatai.me/2013/04/18/using-jekyll.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.soimort.org/posts/101/&#34;&gt;http://www.soimort.org/posts/101/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ruhoh：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://ruhoh.com/&#34;&gt;http://ruhoh.com/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在路由器上搭建博客&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://blog.huatai.me/2013/01/24/how-this-blog-relive.html&#34;&gt;http://blog.huatai.me/2013/01/24/how-this-blog-relive.html&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;挂载移动硬盘&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;lsusb查看是否能找到移动硬盘的硬件&lt;/p&gt;&#xA;&#xA;&lt;p&gt;ls -l /dev/查看sda开头的设备&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先安装ntfs-3g&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sudo apt-get install ntfs-3g&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;sudo mount -t ntfs -o utf-8 /dev/sda5 /mnt/sda5&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;sda5是取决于你的实际情况，a表示第一个硬盘，5表示第5个分区。&#xA;-t ntfs以ntfs文件格式挂载&#xA;-o utf-8 设置文件编码&#xA;开机自动挂载硬盘&#xA;把上述的命令写入 /etc/fstab 文件中&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pi@raspberrypi /mnt/sda5 $ cat /etc/fstab&#xA;proc            /proc           proc    defaults          0       0&#xA;#Handled by Berryboot &#xA;#/dev/mmcblk0p1  /boot           vfat    defaults          0       2&#xA;#/dev/mmcblk0p2  /               ext4    defaults,noatime  0       1&#xA;/dev/sda5   /mnt/sda5   ntfs-3g utf-8,noexec,umask=0000 0   0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;开机启动脚本&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在/etc/init.d/ 下新建svnserve，新建完成后：sudo chmod +x svnserve，加可执行权限&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;# description: script to start/stop svnserve&#xA;case $1 in&#xA;    start)&#xA;        svnserve -d -r /home/pi/svn_repository&#xA;        ;;&#xA;    stop)&#xA;        killall svnserve&#xA;        ;;&#xA;*)&#xA;echo &amp;quot;Usage: $0 (start|stop)&amp;quot;&#xA;;;&#xA;esac&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>你的第一篇博客</title>
      <link>http://sample.com/2012/new-born.html</link>
      <pubDate>2012-12-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢你使用Gor编写博客&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件。&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>读取网络上文件到内存</title>
      <link>http://sample.com/code/%E8%AF%BB%E5%8F%96%E7%BD%91%E7%BB%9C%E4%B8%8A%E6%96%87%E4%BB%B6%E5%88%B0%E5%86%85%E5%AD%98/</link>
      <pubDate>2011-12-19 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;从网络上下载文件到硬盘相对简单，拿到文件输出流，网络上的输入流，一边读输入流一边写输出流，都读取完毕，关掉输入、输出流就好。&#xA;但是读取网络上的文件到内存，由于不知道网络上文件的具体大小，没法申请一个准确的byte数组大小。而且读取网络上的输入流时，是不知道一次能读到的数据包的大小的，必须一点点的读取保存，又涉及byte数组的重新申请，和最后resize一个合适的byte[]，相对麻烦一些，把自己写的一小段代码记录在此，方便日后的使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public byte[] readBytesFromUrl(String urlStr, int initLength) {&#xA;        if (initLength == 0) {&#xA;            return null;&#xA;        }&#xA;        try {&#xA;            URL url = new URL(urlStr);&#xA;            URLConnection conn = url.openConnection();&#xA;            InputStream inputStream = conn.getInputStream();&#xA;            byte[] buffer = new byte[initLength];&#xA;            byte[] temp = new byte[1024];&#xA;            int bytesum = 0;&#xA;            int byteread = 0;&#xA;            while ((byteread = inputStream.read(temp)) != -1) {&#xA;                for (int i = 0; i &amp;lt; byteread; i++) {&#xA;                    int index = bytesum + i;&#xA;                    if (index == buffer.length) {&#xA;                        byte[] newBuffer = new byte[buffer.length + initLength];&#xA;                        for (int j = 0; j &amp;lt; buffer.length; j++) {&#xA;                            newBuffer[j] = buffer[j];&#xA;                        }&#xA;                        buffer = newBuffer;&#xA;                    }&#xA;                    buffer[index] = temp[i];&#xA;                }&#xA;                bytesum += byteread;&#xA;            }&#xA;            if (buffer.length &amp;gt; bytesum) {&#xA;                byte[] newBuffer = new byte[bytesum];&#xA;                for (int i = 0; i &amp;lt; bytesum; i++) {&#xA;                    newBuffer[i] = buffer[i];&#xA;                }&#xA;                buffer = newBuffer;&#xA;            }&#xA;            return buffer;&#xA;        } catch (MalformedURLException e) {&#xA;            e.printStackTrace();&#xA;        } catch (IOException e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;        return null;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>项目中资源文件的获取</title>
      <link>http://sample.com/code/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%8E%B7%E5%8F%96/</link>
      <pubDate>2011-11-09 12:00:00 +0800</pubDate>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;通过类加载器获取&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;InputStream inputStream1 = this.getClass().getClassLoader()&#xA;                .getResourceAsStream(&amp;quot;ExternalResource/data.xml&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;spring ApplicationContext获取&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class SpringApplicationContextHolder implements ApplicationContextAware {&#xA;    private static ApplicationContext context;&#xA;&#xA;    @Override&#xA;    public void setApplicationContext(ApplicationContext context) throws BeansException {&#xA;        SpringApplicationContextHolder.context = context;&#xA;    }&#xA;&#xA;    public static Object getSpringBean(String beanName) {&#xA;        notEmpty(beanName, &amp;quot;bean name is required&amp;quot;);&#xA;        return context.getBean(beanName);&#xA;    }&#xA;&#xA;    public static File getResourceFile(String resource) throws IOException {&#xA;        return context.getResource(resource).getFile();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;需要注意的是，本地调试eclipse编译时只会把固定格式的文件（比如xml）copy到classes目录下，但txt格式的文件它是不会copy过去的。本来正常运行的代码，因为不同的文件格式却怎么也获取不到文件的输入流，在这个小坑里也折腾了好一会儿，记录下来，防止下次忘记了。&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>